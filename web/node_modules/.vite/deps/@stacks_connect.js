import {
  bootstrapLazy,
  promiseResolve
} from "./chunk-BHK3C7LZ.js";
import {
  ChainId,
  NoSessionDataError,
  PostConditionMode,
  TransactionVersion,
  address_exports,
  bytesToHex,
  bytesToUtf8,
  cl_exports,
  deserializeTransaction,
  hexToBytes,
  hmac,
  postConditionToHex,
  require_lib,
  require_lodash,
  sha256,
  utf8ToBytes,
  utils
} from "./chunk-A5NPPGC3.js";
import "./chunk-ERZ3SI3B.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EX4CI3XV.js";

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = function(exports2) {
        var g2 = typeof globalThis !== "undefined" && globalThis || typeof self2 !== "undefined" && self2 || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g2,
          iterable: "Symbol" in g2 && "iterator" in Symbol,
          blob: "FileReader" in g2 && "Blob" in g2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in g2,
          arrayBuffer: "ArrayBuffer" in g2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g2) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g2.location.href ? g2.location.href : url;
              } catch (e2) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g2.Headers && init.headers instanceof g2.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g2.fetch) {
          g2.fetch = fetch2;
          g2.Headers = Headers2;
          g2.Request = Request;
          g2.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(typeof self !== "undefined" ? self : exports);
  }
});

// node_modules/@scure/base/lib/esm/index.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b2) => (c) => a(b2(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to2) => {
      astr("join.decode", to2);
      return to2.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  afn(fn);
  return { encode: (from) => from, decode: (to2) => fn(to2) };
}
function convertRadix(data, from, to2) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to2 < 2)
    throw new Error(`convertRadix: invalid to=${to2}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to2;
      carry = digitBase % to2;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to2 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b2) => b2 === 0 ? a : gcd(b2, a % b2);
var radix2carry = (from, to2) => from + (to2 - gcd(from, to2));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to2, padding2) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to2 <= 0 || to2 > 32)
    throw new Error(`convertRadix2: wrong to=${to2}`);
  if (radix2carry(from, to2) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to2} carryBits=${radix2carry(from, to2)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to2] - 1;
  const res = [];
  for (const n of data) {
    anumber(n);
    if (n >= max)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to2; pos -= to2)
      res.push((carry >> pos - to2 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to2 - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e2) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re2 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re2.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b2) {
    abytes(b2);
    return b2.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b2) {
    abytes(b2);
    return b2.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b2 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b2 >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@stacks/connect-ui/dist/esm/index.js
var LOCAL_STORAGE_KEY = "STX_PROVIDER";
var getSelectedProviderId = () => {
  if (typeof window === "undefined")
    return null;
  return window.localStorage.getItem(LOCAL_STORAGE_KEY);
};
var setSelectedProviderId = (provider) => {
  if (typeof window !== "undefined") {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, provider);
  }
};
var clearSelectedProviderId = () => {
  if (typeof window !== "undefined") {
    window.localStorage.removeItem(LOCAL_STORAGE_KEY);
  }
};
var getRegisteredProviders = () => {
  if (typeof window === "undefined")
    return [];
  const legacyProviders = window.webbtc_stx_providers || [];
  const wbipProviders = window.wbip_providers || [];
  return [...legacyProviders, ...wbipProviders];
};
var getInstalledProviders = (defaultProviders = []) => {
  if (typeof window === "undefined")
    return [];
  const registeredProviders = getRegisteredProviders();
  const additionalInstalledProviders = defaultProviders.filter((defaultProvider) => {
    if (registeredProviders.find((rp) => rp.id === defaultProvider.id))
      return false;
    const provider = getProviderFromId(defaultProvider.id);
    return !!provider;
  });
  return registeredProviders.concat(additionalInstalledProviders);
};
var isProviderSelected = () => {
  return !!getSelectedProviderId();
};
var getProvider = () => {
  const providerId = getSelectedProviderId();
  return getProviderFromId(providerId);
};
var getProviderFromId = (id) => {
  return id === null || id === void 0 ? void 0 : id.split(".").reduce((acc, part) => acc === null || acc === void 0 ? void 0 : acc[part], window);
};

// node_modules/@stacks/connect-ui/dist/esm/loader.js
var patchEsm = () => {
  return promiseResolve();
};
var defineCustomElements = (win, options) => {
  if (typeof window === "undefined") return Promise.resolve();
  return patchEsm().then(() => {
    return bootstrapLazy([["connect-modal", [[1, "connect-modal", { "defaultProviders": [16], "installedProviders": [16], "callback": [16], "cancelCallback": [16] }]]]], options);
  });
};

// node_modules/@stacks/connect-ui/loader/index.js
(function() {
  if ("undefined" !== typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var a = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(a, [], this.constructor);
    };
    HTMLElement.prototype = a.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, a);
  }
})();

// node_modules/@stacks/network-v6/dist/esm/fetch.js
var import_polyfill = __toESM(require_browser_polyfill());
var defaultFetchOpts = {
  referrerPolicy: "origin",
  headers: {
    "x-hiro-product": "stacksjs"
  }
};
async function fetchWrapper(input, init) {
  const fetchOpts = {};
  Object.assign(fetchOpts, defaultFetchOpts, init);
  const fetchResult = await fetch(input, fetchOpts);
  return fetchResult;
}
function argsForCreateFetchFn(args) {
  let fetchLib = fetchWrapper;
  let middlewares = [];
  if (args.length > 0 && typeof args[0] === "function") {
    fetchLib = args.shift();
  }
  if (args.length > 0) {
    middlewares = args;
  }
  return { fetchLib, middlewares };
}
function createFetchFn(...args) {
  const { fetchLib, middlewares } = argsForCreateFetchFn(args);
  const fetchFn = async (url, init) => {
    let fetchParams = { url, init: init ?? {} };
    for (const middleware of middlewares) {
      if (typeof middleware.pre === "function") {
        const result = await Promise.resolve(middleware.pre({
          fetch: fetchLib,
          ...fetchParams
        }));
        fetchParams = result ?? fetchParams;
      }
    }
    let response = await fetchLib(fetchParams.url, fetchParams.init);
    for (const middleware of middlewares) {
      if (typeof middleware.post === "function") {
        const result = await Promise.resolve(middleware.post({
          fetch: fetchLib,
          url: fetchParams.url,
          init: fetchParams.init,
          response: (response == null ? void 0 : response.clone()) ?? response
        }));
        response = result ?? response;
      }
    }
    return response;
  };
  return fetchFn;
}

// node_modules/@stacks/network-v6/node_modules/@stacks/common/dist/esm/errors.js
var ERROR_CODES = {
  MISSING_PARAMETER: "missing_parameter",
  REMOTE_SERVICE_ERROR: "remote_service_error",
  INVALID_STATE: "invalid_state",
  NO_SESSION_DATA: "no_session_data",
  DOES_NOT_EXIST: "does_not_exist",
  FAILED_DECRYPTION_ERROR: "failed_decryption_error",
  INVALID_DID_ERROR: "invalid_did_error",
  NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
  INVALID_AMOUNT_ERROR: "invalid_amount_error",
  LOGIN_FAILED_ERROR: "login_failed",
  SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
  CONFLICT_ERROR: "conflict_error",
  NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
  BAD_PATH_ERROR: "bad_path_error",
  VALIDATION_ERROR: "validation_error",
  PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
  PRECONDITION_FAILED_ERROR: "precondition_failed_error",
  UNKNOWN: "unknown"
};
Object.freeze(ERROR_CODES);

// node_modules/@stacks/network-v6/node_modules/@stacks/common/dist/esm/logger.js
var levels = ["debug", "info", "warn", "error", "none"];
var levelToInt = {};
var intToLevel = {};
for (let index = 0; index < levels.length; index++) {
  const level = levels[index];
  levelToInt[level] = index;
  intToLevel[index] = level;
}

// node_modules/@stacks/network-v6/node_modules/@stacks/common/dist/esm/utils.js
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));

// node_modules/@stacks/network-v6/node_modules/@stacks/common/dist/esm/constants.js
var ChainID;
(function(ChainID4) {
  ChainID4[ChainID4["Testnet"] = 2147483648] = "Testnet";
  ChainID4[ChainID4["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
var TransactionVersion2;
(function(TransactionVersion5) {
  TransactionVersion5[TransactionVersion5["Mainnet"] = 0] = "Mainnet";
  TransactionVersion5[TransactionVersion5["Testnet"] = 128] = "Testnet";
})(TransactionVersion2 || (TransactionVersion2 = {}));
var PeerNetworkID;
(function(PeerNetworkID3) {
  PeerNetworkID3[PeerNetworkID3["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkID3[PeerNetworkID3["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkID || (PeerNetworkID = {}));

// node_modules/@stacks/network-v6/dist/esm/network.js
var HIRO_MAINNET_DEFAULT = "https://api.mainnet.hiro.so";
var HIRO_TESTNET_DEFAULT = "https://api.testnet.hiro.so";
var HIRO_MOCKNET_DEFAULT = "http://localhost:3999";
var StacksNetworks = ["mainnet", "testnet", "devnet", "mocknet"];
var StacksNetwork = class {
  constructor(networkConfig) {
    this.version = TransactionVersion2.Mainnet;
    this.chainId = ChainID.Mainnet;
    this.bnsLookupUrl = "https://api.mainnet.hiro.so";
    this.broadcastEndpoint = "/v2/transactions";
    this.transferFeeEstimateEndpoint = "/v2/fees/transfer";
    this.transactionFeeEstimateEndpoint = "/v2/fees/transaction";
    this.accountEndpoint = "/v2/accounts";
    this.contractAbiEndpoint = "/v2/contracts/interface";
    this.readOnlyFunctionCallEndpoint = "/v2/contracts/call-read";
    this.isMainnet = () => this.version === TransactionVersion2.Mainnet;
    this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;
    this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;
    this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;
    this.getAccountApiUrl = (address) => `${this.coreApiUrl}${this.accountEndpoint}/${address}?proof=0`;
    this.getAccountExtendedBalancesApiUrl = (address) => `${this.coreApiUrl}/extended/v1/address/${address}/balances`;
    this.getAbiApiUrl = (address, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address}/${contract}`;
    this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;
    this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;
    this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;
    this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;
    this.getRewardsUrl = (address, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getRewardsTotalUrl = (address) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}/total`;
    this.getRewardHoldersUrl = (address, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}
    ${contractAddress}/${contractName}/get-stacker-info`;
    this.getDataVarUrl = (contractAddress, contractName, dataVarName) => `${this.coreApiUrl}/v2/data_var/${contractAddress}/${contractName}/${dataVarName}?proof=0`;
    this.getMapEntryUrl = (contractAddress, contractName, mapName) => `${this.coreApiUrl}/v2/map_entry/${contractAddress}/${contractName}/${mapName}?proof=0`;
    this.coreApiUrl = networkConfig.url;
    this.fetchFn = networkConfig.fetchFn ?? createFetchFn();
  }
  getNameInfo(fullyQualifiedName) {
    const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;
    return this.fetchFn(nameLookupURL).then((resp) => {
      if (resp.status === 404) {
        throw new Error("Name not found");
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then((nameInfo) => {
      if (nameInfo.address) {
        return Object.assign({}, nameInfo, { address: nameInfo.address });
      } else {
        return nameInfo;
      }
    });
  }
};
StacksNetwork.fromName = (networkName) => {
  switch (networkName) {
    case "mainnet":
      return new StacksMainnet();
    case "testnet":
      return new StacksTestnet();
    case "devnet":
      return new StacksDevnet();
    case "mocknet":
      return new StacksMocknet();
    default:
      throw new Error(`Invalid network name provided. Must be one of the following: ${StacksNetworks.join(", ")}`);
  }
};
StacksNetwork.fromNameOrNetwork = (network) => {
  if (typeof network !== "string" && "version" in network) {
    return network;
  }
  return StacksNetwork.fromName(network);
};
var StacksMainnet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_MAINNET_DEFAULT,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion2.Mainnet;
    this.chainId = ChainID.Mainnet;
  }
};
var StacksTestnet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_TESTNET_DEFAULT,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion2.Testnet;
    this.chainId = ChainID.Testnet;
  }
};
var StacksMocknet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_MOCKNET_DEFAULT,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion2.Testnet;
    this.chainId = ChainID.Testnet;
  }
};
var StacksDevnet = StacksMocknet;

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/errors.js
var ERROR_CODES2 = {
  MISSING_PARAMETER: "missing_parameter",
  REMOTE_SERVICE_ERROR: "remote_service_error",
  INVALID_STATE: "invalid_state",
  NO_SESSION_DATA: "no_session_data",
  DOES_NOT_EXIST: "does_not_exist",
  FAILED_DECRYPTION_ERROR: "failed_decryption_error",
  INVALID_DID_ERROR: "invalid_did_error",
  NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
  INVALID_AMOUNT_ERROR: "invalid_amount_error",
  LOGIN_FAILED_ERROR: "login_failed",
  SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
  CONFLICT_ERROR: "conflict_error",
  NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
  BAD_PATH_ERROR: "bad_path_error",
  VALIDATION_ERROR: "validation_error",
  PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
  PRECONDITION_FAILED_ERROR: "precondition_failed_error",
  UNKNOWN: "unknown"
};
Object.freeze(ERROR_CODES2);

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/logger.js
var levels2 = ["debug", "info", "warn", "error", "none"];
var levelToInt2 = {};
var intToLevel2 = {};
for (let index = 0; index < levels2.length; index++) {
  const level = levels2[index];
  levelToInt2[level] = index;
  intToLevel2[index] = level;
}

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/utils.js
function intToBytes(value, signed, byteLength) {
  return bigIntToBytes(intToBigInt(value, signed), byteLength);
}
function intToBigInt(value, signed) {
  let parsedValue = value;
  if (typeof parsedValue === "number") {
    if (!Number.isInteger(parsedValue)) {
      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
    }
    if (parsedValue > Number.MAX_SAFE_INTEGER) {
      throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);
    }
    return BigInt(parsedValue);
  }
  if (typeof parsedValue === "string") {
    if (parsedValue.toLowerCase().startsWith("0x")) {
      let hex2 = parsedValue.slice(2);
      hex2 = hex2.padStart(hex2.length + hex2.length % 2, "0");
      parsedValue = hexToBytes3(hex2);
    } else {
      try {
        return BigInt(parsedValue);
      } catch (error) {
        if (error instanceof SyntaxError) {
          throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
        }
      }
    }
  }
  if (typeof parsedValue === "bigint") {
    return parsedValue;
  }
  if (parsedValue instanceof Uint8Array) {
    if (signed) {
      const bn = fromTwos(BigInt(`0x${bytesToHex2(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
      return BigInt(bn.toString());
    } else {
      return BigInt(`0x${bytesToHex2(parsedValue)}`);
    }
  }
  if (parsedValue != null && typeof parsedValue === "object" && parsedValue.constructor.name === "BN") {
    return BigInt(parsedValue.toString());
  }
  throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
function intToHex(integer, lengthBytes = 8) {
  const value = typeof integer === "bigint" ? integer : intToBigInt(integer, false);
  return value.toString(16).padStart(lengthBytes * 2, "0");
}
function bigIntToBytes(value, length = 16) {
  const hex2 = intToHex(value, length);
  return hexToBytes3(hex2);
}
function toTwos(value, width) {
  if (value < -(BigInt(1) << width - BigInt(1)) || (BigInt(1) << width - BigInt(1)) - BigInt(1) < value) {
    throw `Unable to represent integer in width: ${width}`;
  }
  if (value >= BigInt(0)) {
    return BigInt(value);
  }
  return value + (BigInt(1) << width);
}
function nthBit(value, n) {
  return value & BigInt(1) << n;
}
function fromTwos(value, width) {
  if (nthBit(value, width - BigInt(1))) {
    return value - (BigInt(1) << width);
  }
  return value;
}
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (const u2 of uint8a) {
    hex2 += hexes2[u2];
  }
  return hex2;
}
function hexToBytes3(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError(`hexToBytes: expected string, got ${typeof hex2}`);
  }
  hex2 = hex2.startsWith("0x") || hex2.startsWith("0X") ? hex2.slice(2) : hex2;
  const paddedHex = hex2.length % 2 ? `0${hex2}` : hex2;
  const array = new Uint8Array(paddedHex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = paddedHex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function utf8ToBytes2(str) {
  return new TextEncoder().encode(str);
}
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; i++) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function isNotOctet(octet) {
  return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
  if (numbers.some(isNotOctet))
    throw new Error("Some values are invalid bytes.");
  return new Uint8Array(numbers);
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function concatArray(elements) {
  return concatBytes(...elements.map((e2) => {
    if (typeof e2 === "number")
      return octetsToBytes([e2]);
    if (e2 instanceof Array)
      return octetsToBytes(e2);
    return e2;
  }));
}

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/constants.js
var ChainID2;
(function(ChainID4) {
  ChainID4[ChainID4["Testnet"] = 2147483648] = "Testnet";
  ChainID4[ChainID4["Mainnet"] = 1] = "Mainnet";
})(ChainID2 || (ChainID2 = {}));
var TransactionVersion3;
(function(TransactionVersion5) {
  TransactionVersion5[TransactionVersion5["Mainnet"] = 0] = "Mainnet";
  TransactionVersion5[TransactionVersion5["Testnet"] = 128] = "Testnet";
})(TransactionVersion3 || (TransactionVersion3 = {}));
var PeerNetworkID2;
(function(PeerNetworkID3) {
  PeerNetworkID3[PeerNetworkID3["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkID3[PeerNetworkID3["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkID2 || (PeerNetworkID2 = {}));

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/buffer.js
function writeUInt32BE(destination, value, offset = 0) {
  destination[offset + 3] = value;
  value >>>= 8;
  destination[offset + 2] = value;
  value >>>= 8;
  destination[offset + 1] = value;
  value >>>= 8;
  destination[offset] = value;
  return destination;
}

// node_modules/@stacks/transactions-v6/dist/esm/constants.js
var ChainID3;
(function(ChainID4) {
  ChainID4[ChainID4["Testnet"] = 2147483648] = "Testnet";
  ChainID4[ChainID4["Mainnet"] = 1] = "Mainnet";
})(ChainID3 || (ChainID3 = {}));
var DEFAULT_CHAIN_ID = ChainID3.Mainnet;
var MAX_STRING_LENGTH_BYTES = 128;
var CLARITY_INT_SIZE = 128;
var CLARITY_INT_BYTE_SIZE = 16;
var StacksMessageType;
(function(StacksMessageType2) {
  StacksMessageType2[StacksMessageType2["Address"] = 0] = "Address";
  StacksMessageType2[StacksMessageType2["Principal"] = 1] = "Principal";
  StacksMessageType2[StacksMessageType2["LengthPrefixedString"] = 2] = "LengthPrefixedString";
  StacksMessageType2[StacksMessageType2["MemoString"] = 3] = "MemoString";
  StacksMessageType2[StacksMessageType2["AssetInfo"] = 4] = "AssetInfo";
  StacksMessageType2[StacksMessageType2["PostCondition"] = 5] = "PostCondition";
  StacksMessageType2[StacksMessageType2["PublicKey"] = 6] = "PublicKey";
  StacksMessageType2[StacksMessageType2["LengthPrefixedList"] = 7] = "LengthPrefixedList";
  StacksMessageType2[StacksMessageType2["Payload"] = 8] = "Payload";
  StacksMessageType2[StacksMessageType2["MessageSignature"] = 9] = "MessageSignature";
  StacksMessageType2[StacksMessageType2["StructuredDataSignature"] = 10] = "StructuredDataSignature";
  StacksMessageType2[StacksMessageType2["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksMessageType || (StacksMessageType = {}));
var PayloadType;
(function(PayloadType2) {
  PayloadType2[PayloadType2["TokenTransfer"] = 0] = "TokenTransfer";
  PayloadType2[PayloadType2["SmartContract"] = 1] = "SmartContract";
  PayloadType2[PayloadType2["VersionedSmartContract"] = 6] = "VersionedSmartContract";
  PayloadType2[PayloadType2["ContractCall"] = 2] = "ContractCall";
  PayloadType2[PayloadType2["PoisonMicroblock"] = 3] = "PoisonMicroblock";
  PayloadType2[PayloadType2["Coinbase"] = 4] = "Coinbase";
  PayloadType2[PayloadType2["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
  PayloadType2[PayloadType2["TenureChange"] = 7] = "TenureChange";
  PayloadType2[PayloadType2["NakamotoCoinbase"] = 8] = "NakamotoCoinbase";
})(PayloadType || (PayloadType = {}));
var ClarityVersion;
(function(ClarityVersion2) {
  ClarityVersion2[ClarityVersion2["Clarity1"] = 1] = "Clarity1";
  ClarityVersion2[ClarityVersion2["Clarity2"] = 2] = "Clarity2";
  ClarityVersion2[ClarityVersion2["Clarity3"] = 3] = "Clarity3";
})(ClarityVersion || (ClarityVersion = {}));
var AnchorMode;
(function(AnchorMode2) {
  AnchorMode2[AnchorMode2["OnChainOnly"] = 1] = "OnChainOnly";
  AnchorMode2[AnchorMode2["OffChainOnly"] = 2] = "OffChainOnly";
  AnchorMode2[AnchorMode2["Any"] = 3] = "Any";
})(AnchorMode || (AnchorMode = {}));
var AnchorModeNames = ["onChainOnly", "offChainOnly", "any"];
var AnchorModeMap = {
  [AnchorModeNames[0]]: AnchorMode.OnChainOnly,
  [AnchorModeNames[1]]: AnchorMode.OffChainOnly,
  [AnchorModeNames[2]]: AnchorMode.Any,
  [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,
  [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,
  [AnchorMode.Any]: AnchorMode.Any
};
var TransactionVersion4;
(function(TransactionVersion5) {
  TransactionVersion5[TransactionVersion5["Mainnet"] = 0] = "Mainnet";
  TransactionVersion5[TransactionVersion5["Testnet"] = 128] = "Testnet";
})(TransactionVersion4 || (TransactionVersion4 = {}));
var DEFAULT_TRANSACTION_VERSION = TransactionVersion4.Mainnet;
var PostConditionMode2;
(function(PostConditionMode3) {
  PostConditionMode3[PostConditionMode3["Allow"] = 1] = "Allow";
  PostConditionMode3[PostConditionMode3["Deny"] = 2] = "Deny";
})(PostConditionMode2 || (PostConditionMode2 = {}));
var PostConditionType;
(function(PostConditionType2) {
  PostConditionType2[PostConditionType2["STX"] = 0] = "STX";
  PostConditionType2[PostConditionType2["Fungible"] = 1] = "Fungible";
  PostConditionType2[PostConditionType2["NonFungible"] = 2] = "NonFungible";
})(PostConditionType || (PostConditionType = {}));
var AuthType;
(function(AuthType2) {
  AuthType2[AuthType2["Standard"] = 4] = "Standard";
  AuthType2[AuthType2["Sponsored"] = 5] = "Sponsored";
})(AuthType || (AuthType = {}));
var AddressHashMode;
(function(AddressHashMode2) {
  AddressHashMode2[AddressHashMode2["SerializeP2PKH"] = 0] = "SerializeP2PKH";
  AddressHashMode2[AddressHashMode2["SerializeP2SH"] = 1] = "SerializeP2SH";
  AddressHashMode2[AddressHashMode2["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
  AddressHashMode2[AddressHashMode2["SerializeP2WSH"] = 3] = "SerializeP2WSH";
  AddressHashMode2[AddressHashMode2["SerializeP2SHNonSequential"] = 5] = "SerializeP2SHNonSequential";
  AddressHashMode2[AddressHashMode2["SerializeP2WSHNonSequential"] = 7] = "SerializeP2WSHNonSequential";
})(AddressHashMode || (AddressHashMode = {}));
var AddressVersion;
(function(AddressVersion2) {
  AddressVersion2[AddressVersion2["MainnetSingleSig"] = 22] = "MainnetSingleSig";
  AddressVersion2[AddressVersion2["MainnetMultiSig"] = 20] = "MainnetMultiSig";
  AddressVersion2[AddressVersion2["TestnetSingleSig"] = 26] = "TestnetSingleSig";
  AddressVersion2[AddressVersion2["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
var PubKeyEncoding;
(function(PubKeyEncoding2) {
  PubKeyEncoding2[PubKeyEncoding2["Compressed"] = 0] = "Compressed";
  PubKeyEncoding2[PubKeyEncoding2["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding || (PubKeyEncoding = {}));
var FungibleConditionCode;
(function(FungibleConditionCode2) {
  FungibleConditionCode2[FungibleConditionCode2["Equal"] = 1] = "Equal";
  FungibleConditionCode2[FungibleConditionCode2["Greater"] = 2] = "Greater";
  FungibleConditionCode2[FungibleConditionCode2["GreaterEqual"] = 3] = "GreaterEqual";
  FungibleConditionCode2[FungibleConditionCode2["Less"] = 4] = "Less";
  FungibleConditionCode2[FungibleConditionCode2["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode || (FungibleConditionCode = {}));
var NonFungibleConditionCode;
(function(NonFungibleConditionCode2) {
  NonFungibleConditionCode2[NonFungibleConditionCode2["Sends"] = 16] = "Sends";
  NonFungibleConditionCode2[NonFungibleConditionCode2["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));
var PostConditionPrincipalID;
(function(PostConditionPrincipalID2) {
  PostConditionPrincipalID2[PostConditionPrincipalID2["Origin"] = 1] = "Origin";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Standard"] = 2] = "Standard";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Contract"] = 3] = "Contract";
})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));
var AssetType;
(function(AssetType2) {
  AssetType2[AssetType2["STX"] = 0] = "STX";
  AssetType2[AssetType2["Fungible"] = 1] = "Fungible";
  AssetType2[AssetType2["NonFungible"] = 2] = "NonFungible";
})(AssetType || (AssetType = {}));
var TxRejectedReason;
(function(TxRejectedReason2) {
  TxRejectedReason2["Serialization"] = "Serialization";
  TxRejectedReason2["Deserialization"] = "Deserialization";
  TxRejectedReason2["SignatureValidation"] = "SignatureValidation";
  TxRejectedReason2["FeeTooLow"] = "FeeTooLow";
  TxRejectedReason2["BadNonce"] = "BadNonce";
  TxRejectedReason2["NotEnoughFunds"] = "NotEnoughFunds";
  TxRejectedReason2["NoSuchContract"] = "NoSuchContract";
  TxRejectedReason2["NoSuchPublicFunction"] = "NoSuchPublicFunction";
  TxRejectedReason2["BadFunctionArgument"] = "BadFunctionArgument";
  TxRejectedReason2["ContractAlreadyExists"] = "ContractAlreadyExists";
  TxRejectedReason2["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
  TxRejectedReason2["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
  TxRejectedReason2["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
  TxRejectedReason2["BadAddressVersionByte"] = "BadAddressVersionByte";
  TxRejectedReason2["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
  TxRejectedReason2["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
  TxRejectedReason2["TooMuchChaining"] = "TooMuchChaining";
  TxRejectedReason2["ConflictingNonceInMempool"] = "ConflictingNonceInMempool";
  TxRejectedReason2["BadTransactionVersion"] = "BadTransactionVersion";
  TxRejectedReason2["TransferRecipientCannotEqualSender"] = "TransferRecipientCannotEqualSender";
  TxRejectedReason2["TransferAmountMustBePositive"] = "TransferAmountMustBePositive";
  TxRejectedReason2["ServerFailureDatabase"] = "ServerFailureDatabase";
  TxRejectedReason2["EstimatorError"] = "EstimatorError";
  TxRejectedReason2["TemporarilyBlacklisted"] = "TemporarilyBlacklisted";
  TxRejectedReason2["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason || (TxRejectedReason = {}));

// node_modules/@stacks/transactions-v6/dist/esm/utils.js
var import_c32check4 = __toESM(require_lib());
var import_lodash = __toESM(require_lodash());

// node_modules/@stacks/transactions-v6/dist/esm/common.js
var import_c32check = __toESM(require_lib());

// node_modules/@stacks/transactions-v6/dist/esm/postcondition-types.js
var import_c32check2 = __toESM(require_lib());
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
  const prefixLength = lengthPrefixBytes || 1;
  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;
  if (exceedsMaxLengthBytes(content, maxLength)) {
    throw new Error(`String length exceeds maximum bytes ${maxLength}`);
  }
  return {
    type: StacksMessageType.LengthPrefixedString,
    content,
    lengthPrefixBytes: prefixLength,
    maxLengthBytes: maxLength
  };
}

// node_modules/@stacks/transactions-v6/dist/esm/clarity/constants.js
var ClarityType;
(function(ClarityType2) {
  ClarityType2[ClarityType2["Int"] = 0] = "Int";
  ClarityType2[ClarityType2["UInt"] = 1] = "UInt";
  ClarityType2[ClarityType2["Buffer"] = 2] = "Buffer";
  ClarityType2[ClarityType2["BoolTrue"] = 3] = "BoolTrue";
  ClarityType2[ClarityType2["BoolFalse"] = 4] = "BoolFalse";
  ClarityType2[ClarityType2["PrincipalStandard"] = 5] = "PrincipalStandard";
  ClarityType2[ClarityType2["PrincipalContract"] = 6] = "PrincipalContract";
  ClarityType2[ClarityType2["ResponseOk"] = 7] = "ResponseOk";
  ClarityType2[ClarityType2["ResponseErr"] = 8] = "ResponseErr";
  ClarityType2[ClarityType2["OptionalNone"] = 9] = "OptionalNone";
  ClarityType2[ClarityType2["OptionalSome"] = 10] = "OptionalSome";
  ClarityType2[ClarityType2["List"] = 11] = "List";
  ClarityType2[ClarityType2["Tuple"] = 12] = "Tuple";
  ClarityType2[ClarityType2["StringASCII"] = 13] = "StringASCII";
  ClarityType2[ClarityType2["StringUTF8"] = 14] = "StringUTF8";
})(ClarityType || (ClarityType = {}));

// node_modules/@stacks/transactions-v6/dist/esm/clarity/types/intCV.js
var MAX_U128 = BigInt("0xffffffffffffffffffffffffffffffff");
var MIN_U128 = BigInt(0);
var MAX_I128 = BigInt("0x7fffffffffffffffffffffffffffffff");
var MIN_I128 = BigInt("-170141183460469231731687303715884105728");

// node_modules/@stacks/transactions-v6/dist/esm/keys.js
var import_c32check3 = __toESM(require_lib());
utils.hmacSha256Sync = (key, ...msgs) => {
  const h2 = hmac.create(sha256, key);
  msgs.forEach((msg) => h2.update(msg));
  return h2.digest();
};

// node_modules/@stacks/transactions-v6/dist/esm/payload.js
var TenureChangeCause;
(function(TenureChangeCause2) {
  TenureChangeCause2[TenureChangeCause2["BlockFound"] = 0] = "BlockFound";
  TenureChangeCause2[TenureChangeCause2["Extended"] = 1] = "Extended";
})(TenureChangeCause || (TenureChangeCause = {}));

// node_modules/@stacks/transactions-v6/dist/esm/errors.js
var TransactionError = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var SerializationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@stacks/transactions-v6/dist/esm/signature.js
var AuthFieldType;
(function(AuthFieldType2) {
  AuthFieldType2[AuthFieldType2["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
  AuthFieldType2[AuthFieldType2["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
  AuthFieldType2[AuthFieldType2["SignatureCompressed"] = 2] = "SignatureCompressed";
  AuthFieldType2[AuthFieldType2["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));

// node_modules/@stacks/transactions-v6/dist/esm/types.js
function serializeAddress(address) {
  const bytesArray = [];
  bytesArray.push(hexToBytes3(intToHex(address.version, 1)));
  bytesArray.push(hexToBytes3(address.hash160));
  return concatArray(bytesArray);
}
function serializePrincipal(principal) {
  const bytesArray = [];
  bytesArray.push(principal.prefix);
  bytesArray.push(serializeAddress(principal.address));
  if (principal.prefix === PostConditionPrincipalID.Contract) {
    bytesArray.push(serializeLPString(principal.contractName));
  }
  return concatArray(bytesArray);
}
function serializeLPString(lps) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes2(lps.content);
  const length = contentBytes.byteLength;
  bytesArray.push(hexToBytes3(intToHex(length, lps.lengthPrefixBytes)));
  bytesArray.push(contentBytes);
  return concatArray(bytesArray);
}
function serializeAssetInfo(info) {
  const bytesArray = [];
  bytesArray.push(serializeAddress(info.address));
  bytesArray.push(serializeLPString(info.contractName));
  bytesArray.push(serializeLPString(info.assetName));
  return concatArray(bytesArray);
}
function serializePostCondition(postCondition) {
  const bytesArray = [];
  bytesArray.push(postCondition.conditionType);
  bytesArray.push(serializePrincipal(postCondition.principal));
  if (postCondition.conditionType === PostConditionType.Fungible || postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
  }
  if (postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeCV(postCondition.assetName));
  }
  bytesArray.push(postCondition.conditionCode);
  if (postCondition.conditionType === PostConditionType.STX || postCondition.conditionType === PostConditionType.Fungible) {
    if (postCondition.amount > BigInt("0xffffffffffffffff"))
      throw new SerializationError("The post-condition amount may not be larger than 8 bytes");
    bytesArray.push(intToBytes(postCondition.amount, false, 8));
  }
  return concatArray(bytesArray);
}

// node_modules/@stacks/transactions-v6/dist/esm/clarity/serialize.js
function bytesWithTypeID(typeId, bytes) {
  return concatArray([typeId, bytes]);
}
function serializeBoolCV(value) {
  return new Uint8Array([value.type]);
}
function serializeOptionalCV(cv) {
  if (cv.type === ClarityType.OptionalNone) {
    return new Uint8Array([cv.type]);
  } else {
    return bytesWithTypeID(cv.type, serializeCV(cv.value));
  }
}
function serializeBufferCV(cv) {
  const length = new Uint8Array(4);
  writeUInt32BE(length, cv.buffer.length, 0);
  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));
}
function serializeIntCV(cv) {
  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes);
}
function serializeUIntCV(cv) {
  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes);
}
function serializeStandardPrincipalCV(cv) {
  return bytesWithTypeID(cv.type, serializeAddress(cv.address));
}
function serializeContractPrincipalCV(cv) {
  return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));
}
function serializeResponseCV(cv) {
  return bytesWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
  const bytesArray = [];
  const length = new Uint8Array(4);
  writeUInt32BE(length, cv.list.length, 0);
  bytesArray.push(length);
  for (const value of cv.list) {
    const serializedValue = serializeCV(value);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeTupleCV(cv) {
  const bytesArray = [];
  const length = new Uint8Array(4);
  writeUInt32BE(length, Object.keys(cv.data).length, 0);
  bytesArray.push(length);
  const lexicographicOrder = Object.keys(cv.data).sort((a, b2) => a.localeCompare(b2));
  for (const key of lexicographicOrder) {
    const nameWithLength = createLPString(key);
    bytesArray.push(serializeLPString(nameWithLength));
    const serializedValue = serializeCV(cv.data[key]);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringCV(cv, encoding) {
  const bytesArray = [];
  const str = encoding == "ascii" ? asciiToBytes(cv.data) : utf8ToBytes2(cv.data);
  const len = new Uint8Array(4);
  writeUInt32BE(len, str.length, 0);
  bytesArray.push(len);
  bytesArray.push(str);
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringAsciiCV(cv) {
  return serializeStringCV(cv, "ascii");
}
function serializeStringUtf8CV(cv) {
  return serializeStringCV(cv, "utf8");
}
function serializeCV(value) {
  switch (value.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return serializeBoolCV(value);
    case ClarityType.OptionalNone:
    case ClarityType.OptionalSome:
      return serializeOptionalCV(value);
    case ClarityType.Buffer:
      return serializeBufferCV(value);
    case ClarityType.UInt:
      return serializeUIntCV(value);
    case ClarityType.Int:
      return serializeIntCV(value);
    case ClarityType.PrincipalStandard:
      return serializeStandardPrincipalCV(value);
    case ClarityType.PrincipalContract:
      return serializeContractPrincipalCV(value);
    case ClarityType.ResponseOk:
    case ClarityType.ResponseErr:
      return serializeResponseCV(value);
    case ClarityType.List:
      return serializeListCV(value);
    case ClarityType.Tuple:
      return serializeTupleCV(value);
    case ClarityType.StringASCII:
      return serializeStringAsciiCV(value);
    case ClarityType.StringUTF8:
      return serializeStringUtf8CV(value);
    default:
      throw new SerializationError("Unable to serialize. Invalid Clarity Value.");
  }
}

// node_modules/@stacks/transactions-v6/dist/esm/utils.js
var exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? utf8ToBytes2(string).length > maxLengthBytes : false;

// node_modules/@stacks/transactions-v6/node_modules/@stacks/network/dist/esm/fetch.js
var import_polyfill2 = __toESM(require_browser_polyfill());
var defaultFetchOpts2 = {
  referrerPolicy: "origin",
  headers: {
    "x-hiro-product": "stacksjs"
  }
};
async function fetchWrapper2(input, init) {
  const fetchOpts = {};
  Object.assign(fetchOpts, defaultFetchOpts2, init);
  const fetchResult = await fetch(input, fetchOpts);
  return fetchResult;
}
function argsForCreateFetchFn2(args) {
  let fetchLib = fetchWrapper2;
  let middlewares = [];
  if (args.length > 0 && typeof args[0] === "function") {
    fetchLib = args.shift();
  }
  if (args.length > 0) {
    middlewares = args;
  }
  return { fetchLib, middlewares };
}
function createFetchFn2(...args) {
  const { fetchLib, middlewares } = argsForCreateFetchFn2(args);
  const fetchFn = async (url, init) => {
    let fetchParams = { url, init: init ?? {} };
    for (const middleware of middlewares) {
      if (typeof middleware.pre === "function") {
        const result = await Promise.resolve(middleware.pre({
          fetch: fetchLib,
          ...fetchParams
        }));
        fetchParams = result ?? fetchParams;
      }
    }
    let response = await fetchLib(fetchParams.url, fetchParams.init);
    for (const middleware of middlewares) {
      if (typeof middleware.post === "function") {
        const result = await Promise.resolve(middleware.post({
          fetch: fetchLib,
          url: fetchParams.url,
          init: fetchParams.init,
          response: (response == null ? void 0 : response.clone()) ?? response
        }));
        response = result ?? response;
      }
    }
    return response;
  };
  return fetchFn;
}

// node_modules/@stacks/transactions-v6/node_modules/@stacks/network/dist/esm/network.js
var HIRO_MAINNET_DEFAULT2 = "https://api.mainnet.hiro.so";
var HIRO_TESTNET_DEFAULT2 = "https://api.testnet.hiro.so";
var HIRO_MOCKNET_DEFAULT2 = "http://localhost:3999";
var StacksNetworks2 = ["mainnet", "testnet", "devnet", "mocknet"];
var StacksNetwork2 = class {
  constructor(networkConfig) {
    this.version = TransactionVersion3.Mainnet;
    this.chainId = ChainID2.Mainnet;
    this.bnsLookupUrl = "https://api.mainnet.hiro.so";
    this.broadcastEndpoint = "/v2/transactions";
    this.transferFeeEstimateEndpoint = "/v2/fees/transfer";
    this.transactionFeeEstimateEndpoint = "/v2/fees/transaction";
    this.accountEndpoint = "/v2/accounts";
    this.contractAbiEndpoint = "/v2/contracts/interface";
    this.readOnlyFunctionCallEndpoint = "/v2/contracts/call-read";
    this.isMainnet = () => this.version === TransactionVersion3.Mainnet;
    this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;
    this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;
    this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;
    this.getAccountApiUrl = (address) => `${this.coreApiUrl}${this.accountEndpoint}/${address}?proof=0`;
    this.getAccountExtendedBalancesApiUrl = (address) => `${this.coreApiUrl}/extended/v1/address/${address}/balances`;
    this.getAbiApiUrl = (address, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address}/${contract}`;
    this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;
    this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;
    this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;
    this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;
    this.getRewardsUrl = (address, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getRewardsTotalUrl = (address) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}/total`;
    this.getRewardHoldersUrl = (address, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}
    ${contractAddress}/${contractName}/get-stacker-info`;
    this.getDataVarUrl = (contractAddress, contractName, dataVarName) => `${this.coreApiUrl}/v2/data_var/${contractAddress}/${contractName}/${dataVarName}?proof=0`;
    this.getMapEntryUrl = (contractAddress, contractName, mapName) => `${this.coreApiUrl}/v2/map_entry/${contractAddress}/${contractName}/${mapName}?proof=0`;
    this.coreApiUrl = networkConfig.url;
    this.fetchFn = networkConfig.fetchFn ?? createFetchFn2();
  }
  getNameInfo(fullyQualifiedName) {
    const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;
    return this.fetchFn(nameLookupURL).then((resp) => {
      if (resp.status === 404) {
        throw new Error("Name not found");
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then((nameInfo) => {
      if (nameInfo.address) {
        return Object.assign({}, nameInfo, { address: nameInfo.address });
      } else {
        return nameInfo;
      }
    });
  }
};
StacksNetwork2.fromName = (networkName) => {
  switch (networkName) {
    case "mainnet":
      return new StacksMainnet2();
    case "testnet":
      return new StacksTestnet2();
    case "devnet":
      return new StacksDevnet2();
    case "mocknet":
      return new StacksMocknet2();
    default:
      throw new Error(`Invalid network name provided. Must be one of the following: ${StacksNetworks2.join(", ")}`);
  }
};
StacksNetwork2.fromNameOrNetwork = (network) => {
  if (typeof network !== "string" && "version" in network) {
    return network;
  }
  return StacksNetwork2.fromName(network);
};
var StacksMainnet2 = class extends StacksNetwork2 {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_MAINNET_DEFAULT2,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion3.Mainnet;
    this.chainId = ChainID2.Mainnet;
  }
};
var StacksTestnet2 = class extends StacksNetwork2 {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_TESTNET_DEFAULT2,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion3.Testnet;
    this.chainId = ChainID2.Testnet;
  }
};
var StacksMocknet2 = class extends StacksNetwork2 {
  constructor(opts) {
    super({
      url: (opts == null ? void 0 : opts.url) ?? HIRO_MOCKNET_DEFAULT2,
      fetchFn: opts == null ? void 0 : opts.fetchFn
    });
    this.version = TransactionVersion3.Testnet;
    this.chainId = ChainID2.Testnet;
  }
};
var StacksDevnet2 = StacksMocknet2;

// node_modules/@stacks/transactions-v6/dist/esm/builders.js
var import_c32check5 = __toESM(require_lib());

// node_modules/@stacks/transactions-v6/dist/esm/contract-abi.js
var ClarityAbiTypeId;
(function(ClarityAbiTypeId2) {
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
  ClarityAbiTypeId2[ClarityAbiTypeId2["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));

// node_modules/@stacks/transactions-v6/dist/esm/structuredDataSignature.js
var STRUCTURED_DATA_PREFIX = new Uint8Array([83, 73, 80, 48, 49, 56]);

// node_modules/@stacks/connect/dist/index.mjs
var Fe = Object.defineProperty;
var Be = Object.defineProperties;
var We = Object.getOwnPropertyDescriptors;
var w = Object.getOwnPropertySymbols;
var le = Object.prototype.hasOwnProperty;
var ge = Object.prototype.propertyIsEnumerable;
var pe = (e2, t, o) => t in e2 ? Fe(e2, t, { enumerable: true, configurable: true, writable: true, value: o }) : e2[t] = o;
var u = (e2, t) => {
  for (var o in t || (t = {})) le.call(t, o) && pe(e2, o, t[o]);
  if (w) for (var o of w(t)) ge.call(t, o) && pe(e2, o, t[o]);
  return e2;
};
var M = (e2, t) => Be(e2, We(t));
var Se = (e2, t) => {
  var o = {};
  for (var s in e2) le.call(e2, s) && t.indexOf(s) < 0 && (o[s] = e2[s]);
  if (e2 != null && w) for (var s of w(e2)) t.indexOf(s) < 0 && ge.call(e2, s) && (o[s] = e2[s]);
  return o;
};
var I = class e extends Error {
  constructor(o, s, n, r) {
    super(o);
    this.message = o;
    this.code = s;
    this.data = n;
    this.cause = r;
    this.name = "JsonRpcError", this.message = o, this.code = s, this.data = n, this.cause = r;
  }
  static fromResponse(o) {
    return new e(o.message, o.code, o.data);
  }
  toString() {
    return `${this.name} (${this.code}): ${this.message}${this.data ? `: ${JSON.stringify(this.data)}` : ""}`;
  }
};
var fe = ((i) => (i[i.ParseError = -32700] = "ParseError", i[i.InvalidRequest = -32600] = "InvalidRequest", i[i.MethodNotFound = -32601] = "MethodNotFound", i[i.InvalidParams = -32602] = "InvalidParams", i[i.InternalError = -32603] = "InternalError", i[i.UserRejection = -32e3] = "UserRejection", i[i.MethodAddressMismatch = -32001] = "MethodAddressMismatch", i[i.MethodAccessDenied = -32002] = "MethodAccessDenied", i[i.UnknownError = -31e3] = "UnknownError", i[i.UserCanceled = -31001] = "UserCanceled", i))(fe || {});
var Ae = "asigna-stx";
var U = (e2, t) => new Promise((o) => {
  function s(n) {
    n.data.source === Ae && n.data[t] && (o(n.data[t]), window.removeEventListener("message", s));
  }
  window.addEventListener("message", s), window.top.postMessage(Ze(e2, t), "*");
});
var qe = { authenticationRequest: async (e2) => U(e2, "authenticationRequest"), transactionRequest: async (e2) => U(e2, "transactionRequest"), request: async (e2, t) => U(t, e2) };
var Ze = (e2, t) => ({ source: Ae, [t]: e2 });
var ye = () => {
  if (typeof window == "undefined") return;
  window.top !== window.self && (window.AsignaProvider = qe);
};
ye();
var De = [{ id: "LeatherProvider", name: "Leather", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiByeD0iMjYuODM4NyIgZmlsbD0iIzEyMTAwRiIvPgo8cGF0aCBkPSJNNzQuOTE3MSA1Mi43MTE0QzgyLjQ3NjYgNTEuNTQwOCA5My40MDg3IDQzLjU4MDQgOTMuNDA4NyAzNy4zNzYxQzkzLjQwODcgMzUuNTAzMSA5MS44OTY4IDM0LjIxNTQgODkuNjg3MSAzNC4yMTU0Qzg1LjUwMDQgMzQuMjE1NCA3OC40MDYxIDQwLjUzNjggNzQuOTE3MSA1Mi43MTE0Wk0zOS45MTEgODMuNDk5MUMzMC4wMjU2IDgzLjQ5OTEgMjkuMjExNSA5My4zMzI0IDM5LjA5NjkgOTMuMzMyNEM0My41MTYzIDkzLjMzMjQgNDguODY2MSA5MS41NzY0IDUxLjY1NzMgODguNDE1N0M0Ny41ODY4IDg0LjkwMzggNDQuMjE0MSA4My40OTkxIDM5LjkxMSA4My40OTkxWk0xMDIuODI5IDc5LjI4NDhDMTAzLjQxIDk1Ljc5MDcgOTUuMDM2OSAxMDUuMDM5IDgwLjg0ODQgMTA1LjAzOUM3Mi40NzQ4IDEwNS4wMzkgNjguMjg4MSAxMDEuODc4IDU5LjMzMyA5Ni4wMjQ5QzU0LjY4MSAxMDEuMTc2IDQ1Ljg0MjMgMTA1LjAzOSAzOC41MTU0IDEwNS4wMzlDMTMuMjc4NSAxMDUuMDM5IDE0LjMyNTIgNzIuODQ2MyA0MC4wMjczIDcyLjg0NjNDNDUuMzc3MSA3Mi44NDYzIDQ5LjkxMjggNzQuMjUxMSA1NS43Mjc3IDc3Ljg4TDU5LjU2NTYgNjQuNDE3N0M0My43NDg5IDYwLjA4NjQgMzUuODQwNSA0Ny45MTE4IDQzLjYzMjYgMzAuNDY5M0g1Ni4xOTI5QzQ5LjIxNSA0Mi4wNTg2IDUzLjk4MzIgNTEuNjU3OCA2Mi44MjIgNTIuNzExNEM2Ny41OTAzIDM1LjczNzIgNzcuODI0NiAyMi41MDkgOTEuNDMxNiAyMi41MDlDOTkuMTA3NCAyMi41MDkgMTA1LjE1NSAyNy41NDI4IDEwNS4xNTUgMzYuNjczN0MxMDUuMTU1IDUxLjMwNjYgODYuMDgxOSA2My4yNDcxIDcxLjY2MDcgNjQuNDE3N0w2NS43Mjk1IDg1LjM3MjFDNzIuNDc0OCA5My4yMTUzIDkxLjE5OSAxMDAuODI0IDkxLjE5OSA3OS4yODQ4SDEwMi44MjlaIiBmaWxsPSIjRjVGMUVEIi8+Cjwvc3ZnPgo=", webUrl: "https://leather.io", chromeWebStoreUrl: "https://chrome.google.com/webstore/detail/hiro-wallet/ldinpeekobnhjjdofggfgjlcehhmanlj", mozillaAddOnsUrl: "https://leather.io/install-extension" }, { id: "XverseProviders.BitcoinProvider", name: "Xverse Wallet", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2MDAiIGhlaWdodD0iNjAwIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGZpbGw9IiMxNzE3MTciIGQ9Ik0wIDBoNjAwdjYwMEgweiIvPjxwYXRoIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTQ0MCA0MzUuNHYtNTFjMC0yLS44LTMuOS0yLjItNS4zTDIyMCAxNjIuMmE3LjYgNy42IDAgMCAwLTUuNC0yLjJoLTUxLjFjLTIuNSAwLTQuNiAyLTQuNiA0LjZ2NDcuM2MwIDIgLjggNCAyLjIgNS40bDc4LjIgNzcuOGE0LjYgNC42IDAgMCAxIDAgNi41bC03OSA3OC43Yy0xIC45LTEuNCAyLTEuNCAzLjJ2NTJjMCAyLjQgMiA0LjUgNC42IDQuNUgyNDljMi42IDAgNC42LTIgNC42LTQuNlY0MDVjMC0xLjIuNS0yLjQgMS40LTMuM2w0Mi40LTQyLjJhNC42IDQuNiAwIDAgMSA2LjQgMGw3OC43IDc4LjRhNy42IDcuNiAwIDAgMCA1LjQgMi4yaDQ3LjVjMi41IDAgNC42LTIgNC42LTQuNloiLz48cGF0aCBmaWxsPSIjRUU3QTMwIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0zMjUuNiAyMjcuMmg0Mi44YzIuNiAwIDQuNiAyLjEgNC42IDQuNnY0Mi42YzAgNCA1IDYuMSA4IDMuMmw1OC43LTU4LjVjLjgtLjggMS4zLTIgMS4zLTMuMnYtNTEuMmMwLTIuNi0yLTQuNi00LjYtNC42TDM4NCAxNjBjLTEuMiAwLTIuNC41LTMuMyAxLjNsLTU4LjQgNTguMWE0LjYgNC42IDAgMCAwIDMuMiA3LjhaIi8+PC9nPjwvc3ZnPg==", webUrl: "https://xverse.app", chromeWebStoreUrl: "https://chrome.google.com/webstore/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg", googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse", iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513", mozillaAddOnsUrl: "https://www.xverse.app/download" }, { id: "AsignaProvider", name: "Asigna Multisig", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMDEwMCIgZD0iTTAgMGgzMnYzMkgweiIvPjxwYXRoIGZpbGw9InVybCgjYSkiIGQ9Ik0xNS4xMSA1LjU1YTMgMyAwIDAgMC0xLjgyIDEuM2wtLjA1LjA4LS40My43Mi0uMDcuMTEtLjUuODUtLjA1LjA5LTEuMjkgMi4xOC0uMDQuMDctLjQ3LjgtLjA2LjEtLjQ2Ljc4LS4wNy4xMS0xLjYzIDIuNzYtLjA3LjExLS4zOC42Ni0uMDUuMDgtLjczIDEuMjQtLjM1LjYtLjQuNjctLjA1LjA5TDUuMSAyMC43bC0uMTEuMTgtLjE0LjIzLS4wNy4xMy0uMzMuNTUtLjA0LjA3di4wMWExLjI2IDEuMjYgMCAwIDAtLjE0LjQ3IDEuMzEgMS4zMSAwIDAgMCAxLjI0IDEuNGgxLjVsLjA1LS4wNi4wNC0uMDYuODctMS4yMS4wNS0uMDguNzctMS4wNy4wNS0uMDcuNC0uNTcuMDUtLjA2LjI0LS4zNGExLjUyIDEuNTIgMCAwIDEgMS4zOS0uNjIgMS41IDEuNSAwIDAgMSAuNjQuMiAxLjQ3IDEuNDcgMCAwIDEgLjczIDEuMjcgMS40NCAxLjQ0IDAgMCAxLS4yNy44NGwtLjYzLjg4LS4wNS4wNy0uMzIuNDUtLjA2LjA4LS4wOC4xMi0uMTIuMTYtLjA1LjA4aDIuMTNhMi4zMiAyLjMyIDAgMCAwIDEuNzctLjk2bDEuMTgtMS42My43Ny0xLjA4IDEuMy0xLjhhMS4yNCAxLjI0IDAgMCAxIC41NS0uNDNsLjA4LS4wM2ExLjMgMS4zIDAgMCAxIC4zLS4wNiAxLjI4IDEuMjggMCAwIDEgMS4xNS41NGwuMTEuMmExLjEzIDEuMTMgMCAwIDEgLjEuNDEgMS4xOSAxLjE5IDAgMCAxLS4yMy43N2wtLjAzLjA1LS41Ny44LS43Ljk4LS4yNy4zN2ExLjIyIDEuMjIgMCAwIDAtLjIuNSAxLjA1IDEuMDUgMCAwIDAtLjAyLjIzdi4wNmExLjE3IDEuMTcgMCAwIDAgLjE0LjQzbC4wMi4wNS4wNy4xYTEuNDQgMS40NCAwIDAgMCAuMS4xMWwuMDUuMDYuMDEuMDFhMS44IDEuOCAwIDAgMCAuMTQuMWMwIC4wMi4wMi4wMy4wNC4wM2ExIDEgMCAwIDAgLjA4LjA1bC4wNy4wNGExLjI1IDEuMjUgMCAwIDAgLjUuMWg2LjljLjEgMCAuMi0uMDEuMjktLjAzbC4wNi0uMDJhMS4yNyAxLjI3IDAgMCAwIC4yNy0uMS41Ny41NyAwIDAgMCAuMDctLjAzIDEuMjEgMS4yMSAwIDAgMCAuMjYtLjE5bC4wOC0uMDdhLjkyLjkyIDAgMCAwIC4xNS0uMTkgMS41NSAxLjU1IDAgMCAwIC4wOS0uMTdsLjAyLS4wNWExLjIyIDEuMjIgMCAwIDAgLjA4LS4yNnYtLjA0bC4wMi0uMDh2LS4wOGExLjMyIDEuMzIgMCAwIDAtLjItLjc0bC0xLjYtMi42NC0uMDYtLjEtLjItLjMyLS4zMy0uNTR2LS4wMWwtLjA1LS4wOC0xLjMtMi4xNS0uMDctLjEtLjA0LS4wNi0uOC0xLjMyLS4wNC0uMDctLjItLjM0LS4xLS4xNC0uMS0uMTYtLjUzLS45LS4xMy0uMi0uMDktLjE0LTIuMTctMy41Ny0uMDQtLjA3LS43Mi0xLjE5LS4wNS0uMDctLjQtLjY1YTIuNjUgMi42NSAwIDAgMC0uMy0uNCAyLjk2IDIuOTYgMCAwIDAtLjk3LS43NCAzLjA0IDMuMDQgMCAwIDAtMS4zLS4zYy0uMjUgMC0uNS4wNC0uNzQuMVoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMTkgMTYuM2E1LjQ1IDUuNDUgMCAwIDAtLjgzIDEuNTZsLS4wNC4xNWExLjM2IDEuMzYgMCAwIDEgLjI4LS4xNiAxLjI0IDEuMjQgMCAwIDEgLjM4LS4wOGguMWExLjI4IDEuMjggMCAwIDEgMS4wNS41NGMuMDQuMDYuMDguMTMuMS4yYTEuMjQgMS4yNCAwIDAgMSAuMDkuMjcgMS4xOSAxLjE5IDAgMCAxLS4yLjkxbC0uMDQuMDUtLjU3Ljc5LS43Ljk5LS4yNy4zN2ExLjIzIDEuMjMgMCAwIDAtLjIuNDIgMS4wNiAxLjA2IDAgMCAwLS4wMi4zMXYuMDZhMS4xNyAxLjE3IDAgMCAwIC4xNi40Ny45My45MyAwIDAgMCAuMDcuMSAxLjUgMS41IDAgMCAwIC4xLjEybC4wNS4wNmguMDFhMS45NCAxLjk0IDAgMCAwIC4wOS4wOCAxIDEgMCAwIDAgLjE3LjFsLjA3LjA0YTEuMjUgMS4yNSAwIDAgMCAuNS4xaDYuOWMuMSAwIC4yIDAgLjI4LS4wMmwuMDctLjAyYTEuMzIgMS4zMiAwIDAgMCAuMzQtLjEzbC4xNi0uMS4wMy0uMDNhMS4yOSAxLjI5IDAgMCAwIC4yLS4yIDIuNDMgMi40MyAwIDAgMCAuMTItLjE3Yy4wMy0uMDMuMDUtLjA4LjA3LS4xMmwuMDItLjA1YTEuMjEgMS4yMSAwIDAgMCAuMDktLjN2LS4wOGwuMDEtLjA5YTEuMzIgMS4zMiAwIDAgMC0uMi0uNzNsLTEuNi0yLjY0LS4wNi0uMS0uMi0uMzItLjMzLS41NHYtLjAybC0uMDUtLjA3LTEuMy0yLjE1LS4xMi0uMDctLjA3LS4wNGE0Ljk0IDQuOTQgMCAwIDAtMi40Ni0uNjdjLTEuMDMgMC0xLjc2LjU3LTIuMjYgMS4yWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0xMi4yOSAyMS4wOGMwIC4yOS0uMDkuNTgtLjI3Ljg0bC0xLjMxIDEuODRIN2wyLjUyLTMuNTNhMS41NCAxLjU0IDAgMCAxIDIuMS0uMzZjLjQzLjI4LjY2Ljc0LjY2IDEuMloiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTEuMTYgMjEuMjVhLjU2LjU2IDAgMCAxLS41Ny41NS41Ni41NiAwIDAgMS0uNTctLjU2LjU2LjU2IDAgMCAxIC41Ny0uNTUuNTYuNTYgMCAwIDEgLjU3LjU2WiIvPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjE1LjIzIiB4Mj0iMTkuMyIgeTE9IjI1Ljc4IiB5Mj0iNi4xMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM2NTIyRjQiLz48c3RvcCBvZmZzZXQ9Ii41NSIgc3RvcC1jb2xvcj0iIzlCNkJGRiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0E1ODVGRiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iMjIuNTkiIHgyPSIyNC44IiB5MT0iMjQuNzEiIHkyPSIxNS41MyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM0MjFGOEIiLz48c3RvcCBvZmZzZXQ9Ii41NSIgc3RvcC1jb2xvcj0iIzcyMzBGRiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzk3NzNGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==", webUrl: "https://asigna.io", chromeWebStoreUrl: "https://stx.asigna.io/" }, { id: "FordefiProviders.UtxoProvider", name: "Fordefi", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIiIGhlaWdodD0iNDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbD0iIzEwMTExNCIgZD0iTTAgMGg0MnY0MkgweiIvPgogIDxwYXRoIGQ9Ik0xOS40NyAyNi44OUg1djMuNTdhNC41NyA0LjU3IDAgMCAwIDQuNTggNC41N2g1LjgzbDQuMDYtOC4xNFoiIGZpbGw9IiM3OTk0RkYiLz4KICA8cGF0aCBkPSJNNSAxNy40aDI3LjU4bC0zLjIgNi43OEg1VjE3LjRaIiBmaWxsPSIjNDg2REZGIi8+CiAgPHBhdGggZD0iTTE0LjY3IDdINXY3LjY4aDMzVjdoLTkuNjd2NS43NGgtMlY3aC05LjY3djUuNzRoLTEuOTlWN1oiIGZpbGw9IiM1Q0QxRkEiLz4KPC9zdmc+Cg==", webUrl: "https://www.fordefi.com/", chromeWebStoreUrl: "https://chromewebstore.google.com/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle" }];
var z = "@stacks/connect";
var $e = { addresses: { stx: [], btc: [] }, version: "0.0.1" };
var Ie = (e2) => [...new Map(e2.map((o) => [o.address, o])).values()].map((s) => {
  var o = Se(s, []);
  return "publicKey" in o && delete o.publicKey, "derivationPath" in o && delete o.derivationPath, "tweakedPublicKey" in o && delete o.tweakedPublicKey, o;
});
function xe(e2) {
  try {
    let o = G() || $e, s = M(u({}, o), { updatedAt: Date.now(), addresses: u(u({}, o.addresses), e2.addresses && { stx: e2.addresses.stx && Ie([...o.addresses.stx, ...e2.addresses.stx]), btc: e2.addresses.btc && Ie([...o.addresses.btc, ...e2.addresses.btc]) }) });
    localStorage.setItem(z, bytesToHex(utf8ToBytes(JSON.stringify(s))));
  } catch (t) {
    console.warn("Failed to store data in localStorage:", t);
  }
}
function me() {
  try {
    localStorage.removeItem(z);
  } catch (e2) {
    console.warn("Failed to clear localStorage:", e2);
  }
}
function G() {
  try {
    let e2 = localStorage.getItem(z);
    return e2 ? JSON.parse(bytesToUtf8(hexToBytes(e2))) : null;
  } catch (e2) {
    return console.warn("Failed to get data from localStorage:", e2), null;
  }
}
function et() {
  clearSelectedProviderId(), me(), new T().store.deleteSessionData();
}
function tt() {
  let e2 = G();
  return (e2 == null ? void 0 : e2.addresses.stx.length) > 0 || (e2 == null ? void 0 : e2.addresses.btc.length) > 0;
}
async function O(e2, t, o) {
  var s;
  try {
    let n = await e2.request(t, o);
    if ("error" in n) throw I.fromResponse(n.error);
    return n.result;
  } catch (n) {
    if (n instanceof I) throw n;
    if ("jsonrpc" in n) throw I.fromResponse(n.error);
    let r = (s = n.code) != null ? s : -31e3;
    throw new I(n.message, r, n.data, n);
  }
}
function dt(e2) {
  return e2 ? async function(o, s, n) {
    let r = await O(o, s, n);
    if ((s === "getAddresses" || s === "wallet_connect") && "addresses" in r) {
      let { stx: a, btc: c } = At(r.addresses).reduce((d, f) => (d[f.address.startsWith("S") ? "stx" : "btc"].push(f), d), { stx: [], btc: [] });
      xe({ addresses: { stx: a, btc: c } });
    }
    return r;
  } : O;
}
async function P(...e2) {
  let { options: t, method: o, params: s } = ut(e2), n = Object.assign({ provider: getProvider(), defaultProviders: De, forceWalletSelect: false, persistWalletSelect: true, enableOverrides: true, enableLocalStorage: true }, gt(t)), r = St(n.enableOverrides, dt(n.enableLocalStorage));
  if (n.provider && !n.forceWalletSelect) {
    let { method: a, params: c } = Y(n.provider, o, s, n.enableOverrides);
    return await r(n.provider, a, Q(c));
  }
  if (typeof window != "undefined") return defineCustomElements(window), new Promise((a, c) => {
    let d = document.createElement("connect-modal");
    d.defaultProviders = Le(n.approvedProviderIds, n.defaultProviders), d.installedProviders = Le(n.approvedProviderIds, getInstalledProviders(n.defaultProviders));
    let f = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    let i = () => {
      d.remove(), document.body.style.overflow = f;
    };
    d.callback = (m) => {
      i();
      let L = getProviderFromId(m), { method: y, params: j } = Y(L, o, s, n.enableOverrides), v = ft(n.persistWalletSelect, m);
      a(r(L, y, Q(j)).then(v));
    }, d.cancelCallback = () => {
      i(), c(new I("User canceled the request", -31001));
    }, document.body.appendChild(d);
    let x = (m) => {
      m.key === "Escape" && (document.removeEventListener("keydown", x), d.remove(), c(new I("User canceled the request", -31001)));
    };
    document.addEventListener("keydown", x);
  });
}
function ut(e2) {
  return typeof e2[0] == "string" ? { method: e2[0], params: e2[1] } : { options: e2[0], method: e2[1], params: e2[2] };
}
function Le(e2, t) {
  return e2 ? t.filter((o) => e2.includes(o.id)) : t;
}
function Mt(e2) {
  let t = e2 && "network" in e2 ? { network: e2.network } : void 0;
  return P(M(u({}, e2), { forceWalletSelect: true }), "getAddresses", t);
}
function S(e2, t, o) {
  return (s, n) => {
    if (!n) throw new Error("[Connect] No installed Stacks wallet found");
    let r = t(s), a = s, { method: c, params: d } = Y(n, e2, r);
    O(n, c, Q(d)).then((f) => {
      var x;
      let i = o(f);
      (x = a.onFinish) == null || x.call(a, i);
    }).catch(a.onCancel);
  };
}
function h(e2) {
  return pt(e2) || lt(e2);
}
function pt(e2) {
  return "signMultipleTransactions" in e2 && "createRepeatInscriptions" in e2 && !(e2 != null && e2.isLeather) && !(e2 != null && e2.isFordefi);
}
function lt(e2) {
  return "isFordefi" in e2 && !!e2.isFordefi;
}
function Ne(e2) {
  return "isLeather" in e2 && !!e2.isLeather;
}
function gt(e2) {
  if (e2 === void 0) return {};
  let t = {};
  for (let [o, s] of Object.entries(e2)) s !== void 0 && (t[o] = s);
  return t;
}
function St(e2, t) {
  return e2 ? async (o, s, n) => {
    let r = await t(o, s, n), a = u({}, r);
    return r !== null && "txId" in r && r.txId && !("txid" in a) && (a.txid = r.txId), r !== null && "hex" in r && r.hex && typeof r.hex == "string" && !("psbt" in a) && (a.psbt = base64.encode(hexToBytes(r.hex))), a;
  } : t;
}
function Y(e2, t, o, s = true) {
  if (!s) return { method: t, params: o };
  if (h(e2) && ["getAddresses", "stx_getAddresses"].includes(t)) return { method: "wallet_connect", params: o };
  if (h(e2) && t === "sendTransfer") {
    let n = M(u({}, o), { recipients: o.recipients.map((r) => M(u({}, r), { amount: Number(r.amount) })), network: void 0 });
    return { method: t, params: n };
  }
  if (h(e2) && t === "signPsbt") {
    let n = o.signInputs;
    if (!n) return { method: t, params: o };
    let r = {};
    for (let c of n) typeof c != "number" && c.address && (r[c.address] || (r[c.address] = []), r[c.address].push(c.index));
    let a = { psbt: o.psbt, signInputs: r, broadcast: o.broadcast };
    return { method: t, params: a };
  }
  if (!h(e2) && t === "stx_signMessage") {
    let n = u({}, o);
    return delete n.publicKey, { method: t, params: n };
  }
  if (Ne(e2) && t === "sendTransfer") {
    let n = M(u({}, o), { recipients: o.recipients.map((r) => M(u({}, r), { amount: r.amount.toString() })) });
    return { method: t, params: n };
  }
  if (Ne(e2) && t === "signPsbt") {
    let n = { hex: bytesToHex(base64.decode(o.psbt)), signAtIndex: o.signInputs.map((r) => typeof r == "number" ? r : r.index), allowedSighash: o.allowedSighash, broadcast: o.broadcast, network: o.network };
    return { method: t, params: n };
  }
  return { method: t, params: o };
}
var Pe = ["stx-postcondition", "ft-postcondition", "nft-postcondition"];
function Q(e2) {
  if (!e2 || typeof e2 != "object") return e2;
  let t = u({}, e2);
  for (let [o, s] of Object.entries(e2)) {
    if (typeof s == "bigint") {
      t[o] = s.toString();
      continue;
    }
    if (s) {
      if (Array.isArray(s)) {
        t[o] = s.map((n) => typeof n == "bigint" ? n.toString() : !n || typeof n != "object" || !("type" in n) ? n : Pe.includes(n.type) ? postConditionToHex(n) : cl_exports.serialize(n));
        continue;
      }
      typeof s == "object" && "type" in s && (t[o] = Pe.includes(s.type) ? postConditionToHex(s) : cl_exports.serialize(s));
    }
  }
  return t;
}
function ft(e2, t) {
  return function(s) {
    if (e2) try {
      setSelectedProviderId(t);
    } catch (n) {
    }
    return s;
  };
}
function At(e2) {
  return e2.slice().sort((t, o) => {
    let s = "purpose" in t && t.purpose === "payment", n = "purpose" in o && o.purpose === "payment";
    return s && !n ? -1 : !s && n ? 1 : 0;
  });
}
var vo = "https://app.blockstack.org";
typeof window != "undefined" && (window.__CONNECT_VERSION__ = "__VERSION__");
var Uo = () => {
  let e2 = navigator.userAgent;
  return /android/i.test(e2) || /iPad|iPhone|iPod/.test(e2) ? true : /windows phone/i.test(e2);
};
var he = async (e2, t) => {
  var a, c, d, f, i, x;
  let { onFinish: o, onCancel: s, userSession: n } = e2, r = Oe(n);
  r.isUserSignedIn() && r.signUserOut();
  try {
    let L = await P({ provider: t, forceWalletSelect: true }, "getAddresses"), y = r.store.getSessionData();
    (a = y.userData) != null || (y.userData = { profile: {} }), (d = (c = y.userData).profile) != null || (c.profile = {}), (i = (f = y.userData.profile).stxAddress) != null || (f.stxAddress = { mainnet: "", testnet: "" });
    let j = L.addresses.find((A) => (A == null ? void 0 : A.symbol) === "STX" || A.address.startsWith("S")).address.toUpperCase(), v = j[1] === "P" || j[1] === "M";
    Object.assign(y.userData.profile.stxAddress, { [v ? "mainnet" : "testnet"]: j });
    let de = (x = L.addresses.find((A) => {
      var ue;
      return (ue = A == null ? void 0 : A.address) != null && ue.startsWith("S") ? false : A.purpose === "payment" ? true : we(A == null ? void 0 : A.address) ? L.addresses.every((N) => {
        var Me;
        return ((Me = N == null ? void 0 : N.address) == null ? void 0 : Me.startsWith("S")) || we(N == null ? void 0 : N.address);
      }) : true;
    })) == null ? void 0 : x.address;
    de && (y.userData.profile.btcAddress = de), r.store.setSessionData(y), o == null || o({ userSession: r, authResponsePayload: y.userData });
  } catch (m) {
    console.error("[Connect] Error during auth request", m), s == null || s(m);
  }
};
var yt = "blockstack-session";
var E = class {
  constructor(t, o, s, n, r, a) {
  }
};
var T = class {
  constructor(t) {
    t != null && t.appConfig && (this.appConfig = t.appConfig), typeof window == "undefined" && typeof self == "undefined" ? this.store = new F() : this.store = new B();
  }
  makeAuthRequestToken() {
  }
  generateAndStoreTransitKey() {
  }
  getAuthResponseToken() {
  }
  isSignInPending() {
    return false;
  }
  isUserSignedIn() {
    return !!this.store.getSessionData().userData;
  }
  async handlePendingSignIn() {
    return Promise.resolve(this.loadUserData());
  }
  loadUserData() {
    let t = this.store.getSessionData().userData;
    if (!t) throw new NoSessionDataError("No user data found. Did the user sign in?");
    return t;
  }
  encryptContent() {
  }
  decryptContent() {
  }
  signUserOut(t) {
    this.store.deleteSessionData(), t && typeof location != "undefined" && location.href && (location.href = t);
  }
};
var b = class {
  constructor(t) {
    t && this.setSessionData(t);
  }
  getSessionData() {
    throw new Error("Abstract class");
  }
  setSessionData(t) {
    throw new Error("Abstract class");
  }
  deleteSessionData() {
    throw new Error("Abstract class");
  }
};
var F = class extends b {
  constructor(t) {
    super(t), this.sessionData || this.setSessionData({});
  }
  getSessionData() {
    if (!this.sessionData) throw new NoSessionDataError("No session data was found.");
    return this.sessionData;
  }
  setSessionData(t) {
    return this.sessionData = t, true;
  }
  deleteSessionData() {
    return this.setSessionData({}), true;
  }
};
var B = class extends b {
  constructor(t) {
    var s;
    super(t), this.key = typeof ((s = t == null ? void 0 : t.storeOptions) == null ? void 0 : s.localStorageKey) == "string" ? t.storeOptions.localStorageKey : yt, localStorage.getItem(this.key) || this.setSessionData({});
  }
  getSessionData() {
    let t = localStorage.getItem(this.key);
    if (!t) throw new NoSessionDataError("No session data was found in localStorage");
    return JSON.parse(t);
  }
  setSessionData(t) {
    return localStorage.setItem(this.key, JSON.stringify(t)), true;
  }
  deleteSessionData() {
    return localStorage.removeItem(this.key), this.setSessionData({}), true;
  }
};
var Oe = (e2) => e2 || new T();
var zo = async (e2) => (e2 = Oe(e2), e2.isUserSignedIn() ? Promise.resolve(e2.loadUserData()) : Promise.resolve(null));
function we(e2) {
  let t = ["bc1p", "tb1p", "bcrt1p"], o = [62, 62, 64], s = t.findIndex((n) => e2.startsWith(n));
  return s === -1 ? false : e2.length === o[s];
}
var Dt = ((s) => (s.ContractCall = "contract_call", s.ContractDeploy = "smart_contract", s.STXTransfer = "token_transfer", s))(Dt || {});
var It = ((r) => (r.BUFFER = "buffer", r.UINT = "uint", r.INT = "int", r.PRINCIPAL = "principal", r.BOOL = "bool", r))(It || {});
var q = ((r) => (r[r.DEFAULT = 0] = "DEFAULT", r[r.ALL = 1] = "ALL", r[r.NONE = 2] = "NONE", r[r.SINGLE = 3] = "SINGLE", r[r.ANYONECANPAY = 128] = "ANYONECANPAY", r))(q || {});
function g() {
  return getProviderFromId(getSelectedProviderId()) || window.StacksProvider || window.BlockstackProvider;
}
function Nt() {
  return !!g();
}
function Re(e2) {
  return e2 ? typeof e2 == "string" ? StacksNetwork.fromName(e2) : "version" in e2 ? e2 : "url" in e2 ? new StacksMainnet({ url: e2.url }) : e2.transactionVersion === TransactionVersion.Mainnet ? new StacksMainnet({ url: e2.client.baseUrl }) : new StacksTestnet({ url: e2.client.baseUrl }) : new StacksTestnet();
}
function R(e2, t) {
  var o, s;
  return e2 instanceof t || ((s = (o = e2 == null ? void 0 : e2.constructor) == null ? void 0 : o.name) == null ? void 0 : s.toLowerCase()) === t.name;
}
function k(e2) {
  return e2 ? typeof e2 == "string" ? e2 : R(e2, StacksMainnet) ? "mainnet" : R(e2, StacksTestnet) ? "testnet" : R(e2, StacksDevnet) || R(e2, StacksMocknet) ? "devnet" : "coreApiUrl" in e2 ? e2.coreApiUrl : "url" in e2 ? e2.url : "transactionVersion" in e2 ? e2.transactionVersion === TransactionVersion.Mainnet ? "mainnet" : "testnet" : "mainnet" : "mainnet";
}
function D(e2) {
  if (typeof e2.type == "string") return e2;
  switch (e2.type) {
    case ClarityType.BoolFalse:
      return cl_exports.bool(false);
    case ClarityType.BoolTrue:
      return cl_exports.bool(true);
    case ClarityType.Int:
      return cl_exports.int(e2.value);
    case ClarityType.UInt:
      return cl_exports.uint(e2.value);
    case ClarityType.Buffer:
      return cl_exports.buffer(e2.buffer);
    case ClarityType.StringASCII:
      return cl_exports.stringAscii(e2.data);
    case ClarityType.StringUTF8:
      return cl_exports.stringUtf8(e2.data);
    case ClarityType.List:
      return cl_exports.list(e2.list.map(D));
    case ClarityType.Tuple:
      return cl_exports.tuple(Object.fromEntries(Object.entries(e2.data).map(([o, s]) => [o, D(s)])));
    case ClarityType.OptionalNone:
      return cl_exports.none();
    case ClarityType.OptionalSome:
      return cl_exports.some(D(e2.value));
    case ClarityType.ResponseErr:
      return cl_exports.error(D(e2.value));
    case ClarityType.ResponseOk:
      return cl_exports.ok(D(e2.value));
    case ClarityType.PrincipalContract:
      return cl_exports.contractPrincipal(address_exports.stringify(e2.address), e2.contractName.content);
    case ClarityType.PrincipalStandard:
      return cl_exports.standardPrincipal(address_exports.stringify(e2.address));
    default:
      let t = e2;
      throw new Error(`Unknown clarity type: ${t}`);
  }
}
function ke(e2) {
  return M(u({}, e2), { onFinish: void 0, onCancel: void 0 });
}
function Pt(e2) {
}
var jt = async (e2) => {
};
var wt = "stx_updateProfile";
var H = (e2) => e2;
var V = (e2) => e2.profile;
function ht(e2, t = g()) {
  S(wt, H, V)(e2, t);
}
function Ot(e2) {
}
var Et = async (e2) => {
};
var bt = "stx_signMessage";
var K = (e2) => e2;
var J = (e2) => e2;
function Rt(e2, t = g()) {
  S(bt, K, J)(e2, t);
}
async function _t(e2) {
}
var vt = "stx_signStructuredMessage";
var $ = (e2) => ({ message: D(e2.message), domain: D(e2.domain) });
var ee = (e2) => e2;
function Ut(e2, t = g()) {
  if (e2.domain.type !== ClarityType.Tuple) throw new Error("Domain must be a tuple");
  S(vt, $, ee)(e2, t);
}
var ze = (e2) => {
  let t = e2;
  if (!t) {
    let o = new E(["store_write"], document.location.href);
    t = new T({ appConfig: o });
  }
  return t;
};
function Yt(e2) {
  try {
    return ze(e2).loadUserData().appPrivateKey;
  } catch (t) {
    return false;
  }
}
var Qt = (e2) => {
};
function Ft(e2) {
  var d;
  let { stxAddress: t, userSession: o, network: s } = e2;
  if (t) return t;
  if (!o || !s) return;
  let n = (d = o == null ? void 0 : o.loadUserData().profile) == null ? void 0 : d.stxAddress, r = { [ChainId.Mainnet]: "mainnet", [ChainId.Testnet]: "testnet" }, a = Re(s);
  return n == null ? void 0 : n[r[a.chainId]];
}
var Bt = async (e2) => {
};
var Wt = async (e2) => {
};
var qt = async (e2) => {
};
var Zt = async (e2) => {
};
var Xt = "stx_callContract";
var te = (e2) => {
  var o;
  let t = (o = e2.functionArgs) == null ? void 0 : o.map((s) => typeof s == "string" ? cl_exports.deserialize(s) : D(s)).map((s) => cl_exports.serialize(s));
  return M(u({}, e2), { contract: `${e2.contractAddress}.${e2.contractName}`, functionArgs: t, network: k(e2.network), postConditionMode: Ye(e2.postConditionMode), postConditions: Ge(e2.postConditions), address: e2.stxAddress });
};
var oe = (e2) => ({ txId: e2.txid, txRaw: e2.transaction, stacksTransaction: deserializeTransaction(e2.transaction) });
function Ht(e2, t = g()) {
  S(Xt, te, oe)(e2, t);
}
var Vt = "stx_deployContract";
var se = (e2) => M(u({}, e2), { name: e2.contractName, clarityCode: e2.codeBody, network: k(e2.network), postConditionMode: Ye(e2.postConditionMode), postConditions: Ge(e2.postConditions), address: e2.stxAddress });
var ne = (e2) => ({ txId: e2.txid, txRaw: e2.transaction, stacksTransaction: deserializeTransaction(e2.transaction) });
function Kt(e2, t = g()) {
  S(Vt, se, ne)(e2, t);
}
var Jt = "stx_transferStx";
var re = (e2) => M(u({}, e2), { amount: e2.amount.toString(), network: k(e2.network), address: e2.stxAddress });
var ae = (e2) => ({ txId: e2.txid, txRaw: e2.transaction, stacksTransaction: deserializeTransaction(e2.transaction) });
function $t(e2, t = g()) {
  S(Jt, re, ae)(e2, t);
}
var eo = "stx_signTransaction";
var ie = (e2) => M(u({}, e2), { transaction: e2.txHex });
var ce = (e2) => M(u({}, e2), { stacksTransaction: deserializeTransaction(e2.transaction) });
function to(e2, t = g()) {
  S(eo, ie, ce)(e2, t);
}
function Ge(e2) {
  if (typeof e2 != "undefined") return e2.map((t) => typeof t == "string" ? t : typeof t.type == "string" ? M(u({}, t), { amount: "amount" in t ? t.amount.toString() : void 0 }) : bytesToHex(serializePostCondition(t)));
}
function Ye(e2) {
  if (typeof e2 != "undefined") {
    if (typeof e2 == "string") return e2;
    switch (e2) {
      case PostConditionMode.Allow:
        return "allow";
      case PostConditionMode.Deny:
        return "deny";
      default:
        let t = e2;
        throw new Error(`Unknown post condition mode: ${t}. Should be one of: 'allow', 'deny'`);
    }
  }
}
function C(e2, t, o) {
  return (s, n) => {
    let r = t(ke(s)), a = s;
    P({ provider: n }, e2, r).then((c) => {
      var f;
      let d = o(c);
      (f = a.onFinish) == null || f.call(a, d);
    }).catch((c) => {
      var d;
      console.error(c), (d = a.onCancel) == null || d.call(a, c);
    });
  };
}
var oo = he;
var Ps = C("stx_transferStx", re, ae);
var js = C("stx_callContract", te, oe);
var ws = C("stx_deployContract", se, ne);
var hs = C("stx_signTransaction", ie, ce);
var Os = C("stx_updateProfile", H, V);
var Es = C("stx_signMessage", K, J);
var bs = C("stx_signStructuredMessage", $, ee);
var Rs = oo;
function ro(e2) {
}
var ao = async (e2) => {
};
var io = "signPsbt";
var co = (e2) => {
  var t;
  return { psbt: base64.encode(hexToBytes(e2.hex)), signInputs: typeof e2.signAtIndex == "number" ? [e2.signAtIndex] : e2.signAtIndex, allowedSighash: (t = e2.allowedSighash) == null ? void 0 : t.map((o) => q[o]) };
};
var uo = (e2) => ({ hex: bytesToHex(base64.decode(e2.psbt)) });
function Mo(e2, t = g()) {
  S(io, co, uo)(e2, t);
}
export {
  E as AppConfig,
  It as ContractCallArgumentType,
  De as DEFAULT_PROVIDERS,
  F as InstanceDataStore,
  I as JsonRpcError,
  fe as JsonRpcErrorCode,
  yt as LOCALSTORAGE_SESSION_KEY,
  B as LocalStorageStore,
  b as SessionDataStore,
  q as SignatureHash,
  Dt as TransactionTypes,
  T as UserSession,
  he as authenticate,
  me as clearLocalStorage,
  clearSelectedProviderId,
  Mt as connect,
  vo as defaultAuthURL,
  et as disconnect,
  Pt as getDefaultProfileUpdateRequestOptions,
  ro as getDefaultPsbtRequestOptions,
  Ot as getDefaultSignatureRequestOptions,
  Qt as getKeys,
  G as getLocalStorage,
  Oe as getOrCreateUserSession,
  getProvider as getSelectedProvider,
  getSelectedProviderId,
  g as getStacksProvider,
  Ft as getStxAddress,
  zo as getUserData,
  ze as getUserSession,
  Yt as hasAppPrivateKey,
  we as isAddressTaproot,
  tt as isConnected,
  Uo as isMobile,
  isProviderSelected,
  Nt as isStacksWalletInstalled,
  Bt as makeContractCallToken,
  Wt as makeContractDeployToken,
  jt as makeProfileUpdateToken,
  ao as makePsbtToken,
  qt as makeSTXTransferToken,
  Zt as makeSignTransaction,
  Ht as openContractCall,
  Kt as openContractDeploy,
  ht as openProfileUpdateRequestPopup,
  Mo as openPsbtRequestPopup,
  $t as openSTXTransfer,
  to as openSignTransaction,
  Rt as openSignatureRequestPopup,
  Ut as openStructuredDataSignatureRequestPopup,
  P as request,
  O as requestRaw,
  setSelectedProviderId,
  Rs as showBlockstackConnect,
  oo as showConnect,
  js as showContractCall,
  ws as showContractDeploy,
  Os as showProfileUpdate,
  Ps as showSTXTransfer,
  Es as showSignMessage,
  bs as showSignStructuredMessage,
  hs as showSignTransaction,
  Et as signMessage,
  _t as signStructuredMessage
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@stacks_connect.js.map
